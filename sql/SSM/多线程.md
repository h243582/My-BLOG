# 

## 1、共享锁(S锁)读锁

> 若**事务T**对**数据对象A**加上S锁，则**事务T自己都只能读A， 不能修改A**；其他事务只能再对A加S锁，而不能加X锁，直到T释放A上的S锁。





## 2、排他锁(X锁)写锁

又称为*写锁*、独占锁

>若**事务T**对**数据对象A**加上X锁，则**只允许T读取和修改A**，**其他任何事务都不能再对A加任何类型的锁**，不能读写，直到T释放A上的锁。

## 3、二者区别

1、**共享锁只用于*表*级，排他锁用于表级和*行*级**。

2、加了共享锁的对象，可以继续加共享锁，不能再加排他锁。加了排他锁后，不能再加任何锁。

3、比如一个**DML操作(数据增删改操作)**，就要**对受影响的行加排他锁**，别的会话不能修改这些行。同时为了避免在做这个DML操作的时候，有别的会话执行DDL（表结构更改等操作 。还要在表上加共享锁，这样就阻止了DDL操作。

4、当执行DDL操作时，就需要在全表上加排他锁。





# 二、`Lock`和`synchronized`

　　总结来说，`Lock`和`synchronized`有以下几点不同：

　　1）`Lock`是一个接口，而`synchronized`是Java中的关键字，`synchronized`是内置的语言实现；

　　2）`synchronized`在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如果没有主动通过`unLock`()去释放锁，则很可能死锁，因此使用`Lock`时需要在`finally`块中释放锁；

　　3）`Lock`可以让等待锁的线程响应中断，而`synchronized`却不行，使用`synchronized`时，等待的线程会一直等待下去，不能够响应中断；（`I/O`和`Synchronized`都能相应中断，即不需要处理`interruptionException`异常）

　　4）通过`Lock`可以知道有没有**成功获取锁**，而`synchronized`却无法办到。

　　5）`Lock`可以**提高多个线程进行读操作的效率**。

　　在性能上来说，如果竞争资源不激烈，两者的性能是差不多的，而当竞争资源非常激烈时（即有大量线程同时竞争），此时Lock的性能要远远优于synchronized。所以说，在具体使用时要根据适当情况选择。



# 三、锁的种类

## 1、可重入锁

锁具有可重入性，`synchronized`和`Lock`接口的`ReentrantLock`都是可重入锁，从一个线程到另一个线程不需要再申请而是可以直接进去.

```java
class  MyClass {
     public  synchronized  void  method1() {
         method2();
     }
     
     public  synchronized  void  method2() {
         
     }
}
//如果2不具有可重用性，那么1就需要在申请一次自己这个对象的锁，永远申请不到
```

## 2、可中断锁

在Java中，`synchronized`就不是可中断锁，而`Lock`是可中断锁。

　　如果线程A正在执行锁中的代码，线程B不想等待了，想先处理其他事情，我们可以让B中断自己或者在C线程中中断B，这种就是可中断锁。

## 3、公平锁

多个线程在等待一个锁，当这个锁被释放时，**等待时间最久的线程**（最先请求的线程）**获得该锁**

- `synchronized`就是非公平锁，它无法保证等待的线程获取锁的顺序。

- `ReentrantLock`和`ReadWriteLock`接口的`ReentrantReadWriteLock`，它默认情况下是非公平锁，但是可以设置为公平锁。

  - 我们可以在创建`ReentrantLock`对象时，通过以下方式来设置锁的公平性：

  - ```java
    ReentrantLock lock =  new  ReentrantLock( true );
    ```

  - 另外在`ReentrantLock`类中定义了很多方法，比如：

    　　`isFair`()        //判断锁是否是公平锁

      　　`isLocked`()    //判断锁是否被任何线程获取了

      　　`isHeldByCurrentThread`()   //判断锁是否被当前线程获取了

      　　`hasQueuedThreads`()   //判断是否有线程在等待该锁

      　　在`ReentrantReadWriteLock`中也有类似的方法，同样也可以设置为公平锁和非公平锁。不过要记住，`ReentrantReadWriteLock`并未实现Lock接口，它实现的是`ReadWriteLock`接口。

## 4、`ReentrantReadWriteLock`

　　`ReentrantReadWriteLock`里面提供了很多丰富的方法，不过最主要的有两个方法：`readLock`()和`writeLock`()用来获取读锁和写锁。

==下面这个是`synchronize`==

**这段程序的输出结果会是，直到thread1执行完读操作之后，才会打印thread2执行读操作的信息。**

```java
public  class  Test {
     private  ReentrantReadWriteLock rwl =  new  ReentrantReadWriteLock();
     
     public  static  void  main(String[] args)  {
         final  Test test =  new  Test();
         
         new  Thread(){
             public  void  run() {
                 test.get(Thread.currentThread());
             };
         }.start();
         
         new  Thread(){
             public  void  run() {
                 test.get(Thread.currentThread());
             };
         }.start();
         
     }  
     
     public  synchronized  void  get(Thread thread) {
         long  start = System.currentTimeMillis();
         while (System.currentTimeMillis() - start <=  1 ) {
             System.out.println(thread.getName()+ "正在进行读操作" );
         }
         System.out.println(thread.getName()+ "读操作完毕" );
     }
}
```

==下面这个是`ReentrantReadWriteLock`==

**thread1和thread2在同时进行读操作。**

- 如果有**线程A**已经占用了**读锁**，则此时**线程B**如果要申请**写锁**，则**线程B**会一直等待A释放
- 如果有**线程A**已经占用了**写锁**，则此时**线程B**读写都要一直等待**线程A**释放。

```java
public class Test2 {
    private ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();

    public static void main(String[] args) {
        final Test2 test = new Test2();
        new Thread() {
            public void run() {
                test.get(Thread.currentThread());
            }
        }.start();

        new Thread() {
            public void run() {
                test.get(Thread.currentThread());
            }
        }.start();
    }

    public void get(Thread thread) {
        rwl.readLock().lock();
        try {
            long start = System.currentTimeMillis();

            while (System.currentTimeMillis() - start <= 1) {
                System.out.println(thread.getName() + "正在进行读操作");
            }
            System.out.println(thread.getName() + "读操作完毕");
        } finally {
            rwl.readLock().unlock();
        }
    }
}
```



# 四、线程间通讯

## 1、使用 `volatile` 关键字

```java
//定义一个共享变量来实现通信，它需要是volatile修饰，否则线程不能及时感知
static volatile boolean notice = false;
```

多个线程同时监听一个变量，当这个变量发生变化的时候 ，线程能够感知并执行相应的业务。这也是最简单的一种实现方式

## 2、使用Object类的`wait`() 和 `notify`() 方法

==Object类提供了线程间通信的方法：`wait()`、`notify()`、`notifyaAl()`==

> **注意： wait和 notify必须配合synchronized使用，wait方法释放锁，notify方法不释放锁**
>
> 程A发出notify()唤醒通知之后，依然是走完了自己线程的业务之后，线程B才开始执行，这也正好说明了，notify()方法不释放锁，而wait()方法释放锁。

```java
public class TestSync {
    public static void main(String[] args) throws InterruptedException {
        // 定义一个锁对象
        Object lock = new Object();
        List<String> list = new ArrayList<>();
        // 实现线程A
        Thread threadA = new Thread(() -> {
            synchronized (lock) {
                for (int i = 1; i <= 10; i++) {
                    list.add("abc");
                    System.out.println("线程A向list中添加一个元素，此时list中的元素个数为：" + list.size());
                    Thread.sleep(500);
                    if (list.size() == 5)  lock.notify();// 唤醒B线程
                }
            }
        });
        // 实现线程B
        Thread threadB = new Thread(() -> {
            while (true) {
                synchronized (lock) {
                    if (list.size() != 5)   lock.wait();
                    System.out.println("线程B收到通知，开始执行自己的业务...");
                }
            }
        });
        //　需要先启动线程B
        threadB.start();
        Thread.sleep(1000);
        // 再启动线程A
        threadA.start();
    }
}
```

## 3、使用`JUC`工具类 `CountDownLatch`

`jdk1.5`之后在`java.util.concurrent`包下提供了很多并发编程相关的工具类，简化了我们的并发编程代码的书写，`CountDownLatch`基于AQS框架，相当于也是维护了一个线程间共享变量state

```java
public class TestSync4 {
    public static void main(String[] args) {
        CountDownLatch countDownLatch = new CountDownLatch(1);
        List<String> list = new ArrayList<>();
        // 实现线程A
        Thread threadA = new Thread(() -> {
            for (int i = 1; i <= 10; i++) {
                list.add("abc");
                System.out.println("线程A向list中添加一个元素，此时list中的元素个数为：" + list.size());
                if (list.size() == 5)
                    countDownLatch.countDown();//用于使计数器减一，其一般是执行任务的线程调用
            }
        });
        // 实现线程B
        Thread threadB = new Thread(() -> {
            if (list.size() != 5)      countDownLatch.await(); //主线程唤醒
            System.out.println("线程B收到通知，开始执行自己的业务...");
        });
        //　需要先启动线程B
        threadB.start();
        Thread.sleep(1000);

        // 再启动线程A
        threadA.start();
    }
}
```

## 4、使用 ReentrantLock 结合 Condition

这种方式并不是很好，代码编写复杂，A在唤醒操作之后，并不释放锁。这种方法跟 ***Object*** 的 ***wait()*** 和 ***notify()*** 一样。

```java
public class TestSync3 {
    public static void main(String[] args) {
        List<String> list = new ArrayList<>();

        ReentrantLock lock = new ReentrantLock();
        Condition condition = lock.newCondition();

        // 实现线程A
        Thread threadA = new Thread(() -> {
            lock.lock();  //加锁
            for (int i = 1; i <= 10; i++) {
                list.add("abc");
                System.out.println("线程A向list中添加一个元素，此时list中的元素个数为：" + list.size());
                Thread.sleep(500);
                if (list.size() == 5)
                    condition.signal();  //唤醒等待的线程，但是等待的还是要等自己先执行完释放
            }
            lock.unlock();
        });
        // 实现线程B
        Thread threadB = new Thread(() -> {
            lock.lock();
            System.out.println("先执行B");
            if (list.size() != 5) {
                 condition.await(); //让线程B进入等待,执行别的线程
            }
            System.out.println("线程B收到通知，开始执行自己的业务...");
            lock.unlock(); //释放锁
        });

        threadB.start();
        Thread.sleep(1000);
        threadA.start();
    }
}
```





## 5、基本LockSupport实现线程间的阻塞和唤醒

***LockSupport*** 是一种非常灵活的实现线程间阻塞和唤醒的工具，使用它不用关注是等待线程先进行还是唤醒线程先运行，但是得知道线程的名字。

```java
public class TestSync2 {
    public static void main(String[] args) {
        List<String> list = new ArrayList<>();
        // 实现线程B
        final Thread threadB = new Thread(() -> {
            if (list.size() != 5) {
                LockSupport.park(); //挂起当前线程
            }
            System.out.println("线程B收到通知，开始执行自己的业务...");
        });
        // 实现线程A
        Thread threadA = new Thread(() -> {
            for (int i = 1; i <= 10; i++) {
                list.add("abc");
                System.out.println("线程A向list中添加一个元素，此时list中的元素个数为：" + list.size());
                Thread.sleep(500);
                if (list.size() == 5)
                    LockSupport.unpark(threadB);//恢复threadB线程
            }
        });
        threadA.start();
        threadB.start();
    }
}
```

# 五、乐观锁和悲观锁

## 1、乐观锁：

​	读取的时候不加锁数据，写的时候判断有没有被修改过，如果被修改过就不更新

​		**适合大量的读取操作**

## 2、悲观锁：

只要获取事务就要修改，其他对这个事务操作的线程全部等待

​		**适合大量写入的操作**

 

区别，一个读取的时候锁住，一个读取的时候不锁

# 六、synchronized和ReentrantLock区别

1、他们两个都时对于一个数据的同步操作

2、他们都是可重入锁

3、加synchronized锁的时候只需要套一个关键字或者方法上面加一个synchronize修饰就行，已经包装好的。加ReentrantLock的时候需要定义类，比较麻烦

4、synchronize是基于jvm的自动执行的。reentrantLook是基于jdk的手动新建类

# 七、如何处理线程的返回值

## 1、主线程一直等待

等到主线程返回值给他，再执行

```java
while (cw.value == null){
	Thread.sleep(100);
}
```

## 2、使用Thread类的join()方法阻塞当前线程以等待子线程处理完毕

```java
thread.join();
```

## 3、通过Callable接口实现：通过FutureTask Or 线程池获取

## 4、线程池

# 八、JMM内存模型

![202109142257965](https://heyufei-1305336662.cos.ap-shanghai.myqcloud.com/my_img/202109150906108.png)

# 九、线程池执行过程

参数：最大核心数，工作队列，最大线程数，非核心线程生命时间，拒绝策略

