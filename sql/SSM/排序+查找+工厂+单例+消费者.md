# 1、时间复杂度（最坏时间复杂度）

一个算法中的语句执行次数称为语句频度或时间频度，记为T(n)。

- 忽略常数项
- 忽略低次项
- 忽略系数

一般情况下，算法中的基本操作语句的重复执行次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n)，使得当n趋近于无穷大时，T(n) / f(n) 的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作 T(n)=Ｏ( f(n) )，称Ｏ( f(n) ) 为算法的渐进时间复杂度，简称时间复杂度。

常见时间复杂度（按从小到大排列）

1. 常数阶O(1)
2. 对数阶O(log2n)
3. 线性阶O(n)
4. 线性对数阶O(nlog2n)
5. 平方阶O(n^2)
6. 立方阶O(n^3)
7. k次方阶O(n^k)
8. 指数阶O(2^n)

在做算法分析时，主要讨论的是时间复杂度。从用户使用体验上看，更看重的程序执行的速度。一些缓存产品(redis, memcache)和算法(基数排序)本质就是用空间换时间.





# 2、排序算法

## 1.0、算法分类

十种常见排序算法可以分为两大类：

- **比较类排序**（非线性）：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)
- **非比较类排序**（线性）：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行



![img](https://gitee.com/anshao0625/blog-imgs/raw/master/img/849589-20190306165258970-1789860540.png)

![img](https://heyufei-1305336662.cos.ap-shanghai.myqcloud.com/my_img/20210712201214.png)

> 时间复杂度是 **O(nlog2n)** 的有：**归并排序**以及**堆排序**，**快速排序**平均和最好时间复杂度也可



> ​	**稳定**的排序有：**冒泡排序**，**插入排序**，归并排序，以及所有的非比较排序。



> 总结：归并排序既稳定，时间复杂度又低，就是空间复杂度较高。

### 如何选择合适的排序算法

==考虑点1==：如果待排序列基本有序

可以选择冒泡排序和插入排序，时间复杂度直逼 O(n)

==考虑点2==：如果待排序基本无序（通常）

数据量少的时候，还是可以选插入排序，但数据量大的时间，就要选择时间复杂度更优的排序算法，比如归并、快排、堆，这些时间复杂度都是 O(nlogn)。

但是如果选择了快速排序，而每次选择的基准数都是剩余数据里的最大值或最小值的话（序列有序或完全倒序），则快速排序时间复杂度退化到O（n^2）。

==考虑点3==：如果是排名之类的，需要保证稳定性的排序

则只能使用冒泡、插入、归并这些稳定性好的算法 。

> 总结来看：一般情况下，快速排序和希尔排序在排序速度上表现是比较优秀的，而归并排序稍微次之



## 1.1、冒泡排序On<sup>2</sup>

基本思想：一次比较相邻的两个数，比较如果大就交换位置。一次遍历之后，最大的元素就在数列的末尾！ 采用相同的方法再次遍历时，第二大的元素就被排列在最大元素之前。重复此操作，直到整个数列都有序为止！

1. 一共进行数组的大小 -1 次大的循环
2. 依次比较相邻的元素，如果发现逆序就交换

优化：如果发现某一趟排序中，没有发生一次交换，可以提前结束排序

![img](https://heyufei-1305336662.cos.ap-shanghai.myqcloud.com/my_img/20210713090324.gif)

代码实现：

```java
public static void sort(int[] arr) {
        int temp = 0;   //临时变量
        boolean flag = false;     //标记变量

        for (int i = 0; i < arr.length - 1; i++) {
            for (int j = 0; j < arr.length - 1 - i; j++) {
                if (arr[j] > arr[j + 1]) {        //判断是否逆序，逆序则交换
                    flag = true;
                    temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                }
            }

            //判断是否已经有序
            if (!flag) {
                break;
            } else {
                flag = false;
            }
        }
    }
```

## 1.2、选择排序On<sup>2</sup>

基本思想：需要遍历若干次待排序的数列，每次循环时假设第 i 位最小，从 i 到 N进行扫描，选择最小的和 i 进行交换

**算法分析：**

​		无论什么数据进去都是 O(n2) 的时间复杂度，所以用到它的时候，数据**规模越小越好**。唯一的好处可能就是不占用额外的内存空间了吧。

![img](https://heyufei-1305336662.cos.ap-shanghai.myqcloud.com/my_img/20210713090755.gif)

代码实现：

```java
public static void sort(int[] arr) {
        int min = 0;
        int minIndex = 0;
        for (int i = 0; i < arr.length - 1; i++) {
            min = arr[i];    //定义最小值
            minIndex = i;    //定义最小值的下标
          
            //查找最小值与最小值的下标
            for (int j = i + 1; j < arr.length; j++) {
                if (min > arr[j]) {
                    min = arr[j];
                    minIndex = j;
                }
            }
            //判断是否需要交换
            if (minIndex != i) {   
                arr[minIndex] = arr[i];
                arr[i] = min;
            }
        }
    }
```

## 1.3、插入排序On<sup>2</sup>



### 基本思想：

把数列分为为一个**有序表**和一个**无序表**。开始时有序表中只包含1个元素，无序表中包含有n-1个元素，排序过程中每次从无序表中取出第一个元素，将它插入到有序表中的适当位置，使之成为新的有序表，重复n-1次可完成排序过程。

### 算法分析：

插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，**需要反复把已排序元素逐步向后挪位**，为最新元素提供插入空间。

#### 存在的问题：

当需要插入的数是较小的数时，后移的次数明显增多，对效率有影响。所以需要用到希尔排序（更高效），又叫做缩小增量排序。

![img](https://heyufei-1305336662.cos.ap-shanghai.myqcloud.com/my_img/20210713091110.gif)



代码如下：

````java
public static void sort(int[] arr) {
        int insertVal = 0; //待插入的元素
        int insertIndex = 0;  //待插入的前一个位置

        for (int i = 1; i < arr.length; i++) {
            insertVal = arr[i];
            insertIndex = i - 1;
            //与前面的元素进行比较，寻找插入的位置
            while (insertIndex >= 0 && insertVal < arr[insertIndex]) {
                //元素后移，给待插入元素空出一个位置
                arr[insertIndex + 1] = arr[insertIndex];
                insertIndex--;
            }
            //找到待插入的位置，插入待插入元素
            if (insertIndex != i - 1) {
                arr[insertIndex + 1] = insertVal;
            }
        }
    }
````



## 1.4、希尔排序On<sup>1.3</sup>（插入排序优化版）

### 基本思想：

希尔排序实质上是一种分组插入方法。它的基本思想是: 对于n个待排序的数列，取一个小于n的整数gap(gap被称为步长)将待排序元素分成若干个组子序列，所有距离为gap的倍数的记录放在同一个组中；然后，对各组内的元素进行直接插入排序。 这一趟排序完成之后，每一个组的元素都是有序的。然后减小gap的值，并重复执行上述的分组和排序。重复这样的操作，当gap=1时，整个数列就是有序的。

### 算法分析：

希尔排序的核心在于间隔序列的设定。既可以提前设定好间隔序列，也可以动态的定义间隔序列。动态定义间隔序列的算法是《算法（第4版）》的合著者Robert Sedgewick提出的。　

### 代码实现：

```java
public void  shellSort(int[] arr) {
    int len = arr.length;
    for (int gap = len / 2; gap > 0; gap = gap / 2) {
        // 注意：这里和动图演示的不一样，动图是分组执行，实际操作是多个分组交替执行
        for (int i = gap; i < len; i++) {
            int j = i;
            int current = arr[i];
            while (j - gap >= 0 && current < arr[j - gap]) {
                arr[j] = arr[j - gap];
                j = j - gap;
            }
            arr[j] = current;
        }
    }
}
```





## 1.5、快速排序

基本思想：

选择一个基准数，通过一趟排序将要排序的数据分割成独立的两部分；其中一部分的所有数据都比另外一部分的所有数据都要小。然后，再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。

![picture3.1](https://heyufei-1305336662.cos.ap-shanghai.myqcloud.com/my_img/202108261239638.png)

首先哨兵 **j** 开始出动。因为此处设置的基准数是最左边的数，所以需要让哨兵 **j** 先出动，这一点非常重要（请自己想一想为什么）。哨兵 **j** 一步一步地向左挪动（即 **j--**），直到找到一个小于 **6** 的数停下来。接下来哨兵 **i** 再一步一步向右挪动（即 **i++**），直到找到一个数大于 **6** 的数停下来。最后哨兵 **j** 停在了数字 **5** 面前，哨兵 **i** 停在了数字 **7** 面前。

![picture3.2](https://heyufei-1305336662.cos.ap-shanghai.myqcloud.com/my_img/20210714172502.png)

![picture3.3](https://heyufei-1305336662.cos.ap-shanghai.myqcloud.com/my_img/20210714172506.png)

![picture3.4](https://heyufei-1305336662.cos.ap-shanghai.myqcloud.com/my_img/20210714172518.png)

![picture3.5](https://heyufei-1305336662.cos.ap-shanghai.myqcloud.com/my_img/20210714172522.png)

![picture3.6](https://heyufei-1305336662.cos.ap-shanghai.myqcloud.com/my_img/20210714172531.png)

![picture3.7](https://heyufei-1305336662.cos.ap-shanghai.myqcloud.com/my_img/20210714172534.png)

![picture3.8](https://heyufei-1305336662.cos.ap-shanghai.myqcloud.com/my_img/20210714172539.png)



代码实现：

```java
public static void sort(int[] arr, int left, int right) {
    sum++;
    //如果左边界大于右边界则结束递归
    if (left >= right) {
        return;
    }
    int i = left;  //暂存左边界
    int j = right;   //暂存右边界
    int base = arr[left];//base中存放基准数【左边界值】

    //i == j代表左右两边的指针已经重合，不需要再比较了
    while (i != j) {
        //先从右往左找，直到找出比base值小的数
        while (j > i && arr[j] >= base) {
            j--;
        }
        //先从左往右找，直到找出比base值大的数
        while (i < j && arr[i] <= base) {
            i++;
        }
        //交换比其次数小的数与比基准数大的数的位置
        if (i != j) {
            int temp = arr[i];
            arr[i] = arr[j];
            arr[j] = temp;
        }
    }
    //将基准数放到中间位置【基准数归位】
    arr[left] = arr[i];
    arr[i] = base;
    //递归
    sort(arr, left, i - 1);
    sort(arr, i + 1, right);
}
```

`什么情况下快排的查询效率最低`：

最坏情况下，是整个序列都已经有序或完全倒序

此时,快速排序退化为冒泡排序,要比较n2次才能完成

## 1.6、归并排序Onlogn

基本思想：

归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and  Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。 

- 把长度为 n 的输入序列分成两个长度为 n/2 的子序列
- 对这两个子序列分别采用归并排序
- 将两个排序好的子序列合并成一个最终的排序序列

算法分析：

归并排序是一种稳定的排序方法。和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O(nlogn）的时间复杂度。代价是需要额外的内存空间。

![img](https://heyufei-1305336662.cos.ap-shanghai.myqcloud.com/my_img/202108261252755.jpeg)

代码实现：

````java
     /**
     * 分
     * @param arr   待排序数组
     * @param left  左边索引
     * @param right 右边索引
     * @param temp  临时数组
     */
    public static void sort(int[] arr, int left, int right, int[] temp) {
        int mid = 0;
        if (left < right) {
            mid = (left + right) / 2;
            //向左递归进行分解
            sort(arr, left, mid, temp);
            //向右递归进行分解
            sort(arr, mid + 1, right, temp);
            //合并
            add(arr, left, mid, right, temp);
        }
    }

    /**
     * 合(排序)
     *
     * @param arr   排序的原始数组
     * @param left  左边有序序列的初始索引
     * @param mid   中间索引
     * @param right 右边索引
     * @param temp  临时数组
     */
    public static void add(int[] arr, int left, int mid, int right, int[] temp) {
        int i = left;      //左序列的起始位置
        int j = mid + 1;   //右序列的起始位置
        int t = 0;   //指向临时数组的当前索引

        //将两边的数组所有元素整按大小放入临时数组，直到一边全部存入
        while (i <= mid && j <= right) {
            if (arr[i] < arr[j]) {
                temp[t++] = arr[i++];
            } else {
                temp[t++] = arr[j++];
            }
        }
        //将剩余数据的一边的数据依次全部放入临时数组
        while (i <= mid) {
            temp[t++] = arr[i++];
        }
        while (j <= right) {
            temp[t++] = arr[j++];
        }
        //复制临时数组的数据到原始数组，但不是拷贝所有，只拷贝left到right之间的值
        t = 0;
        while (left <= right) {
            arr[left++] = temp[t++];
        }
    }
````

## 1.7、堆排序Onlogn

堆排序是利用堆这种数据结构而设计的排序算法，**堆排序是一种选择排序**，它的最坏，最好，平均时间复杂度均为 O(nlogn)，它也不是稳定的排序。

堆是具有以下性质的**完全二叉树**：**结点 >= 左右孩子** ，称为大顶堆(倒序)。结点 <= 左右孩子，称为小顶堆（从小到大）。

堆排序的基本思想是： 

1. 将无序列表构建成一个堆，根据升降序需求选择大顶堆或小顶堆
2. 将堆顶元素与末尾元素进行交换，将最大的元素“沉”到数组末尾
3. 重新调整结构，使其满足堆的定义，然后继续交换堆顶元素和当前末尾元素，反复执行调整+交换步骤，直到整个序列有序

![img](https://images2017.cnblogs.com/blog/849589/201710/849589-20171015231308699-356134237.gif)

代码如下：

```java
public class Demo2 {
    public static void heapsort(int[] tree, int n, int i) {
        if (i == n)   return;
        int c1 = 2 * i + 1;
        int c2 = 2 * i + 2;
        int max = i;
        if (c1 < n && tree[c1] > tree[max])            max = c1;
        if (c2 < n && tree[c2] > tree[max])            max = c2;
        if (max != i) {
            int temp = tree[i];
            tree[i] = tree[max];
            tree[max] = temp;
            heapsort(tree, n, max);
        }
    }

    public static void main(String[] args) {
        int[] tree = {3,6,1,4,5,2,7,8};
        int n = tree.length;
        for (int j = n - 1; j >= 0; j--) {
            for (int i = (j - 1) / 2; i >= 0; i--) {  heapsort(tree, j+1, i); }
            int temp = tree[0];
            tree[0] = tree[j];
            tree[j] = temp;
        }
        System.out.println(Arrays.toString(tree));
    }
}
```



## 1.8、基数排序

基本思想：

> 把个位，十位，百位分别进行计数排序

​       将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次计数排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。

- 找出待排序的数组中最大和最小的元素；
- 统计数组中每个值为 i 的元素出现的次数，存入数组 C 的第 i 项；
- 对所有的计数累加（从 C 中的第一个元素开始，每一项和前一项相加）
- 反向填充目标数组：将每个元素i放在新数组的第 C(i) 项，每放一个元素就将 C(i) 减去 1。



![img](https://gitee.com/anshao0625/blog-imgs/raw/master/img/alg-sort-radix-1.jpg)

代码如下：

```java
public static void sort(int[] arr) {
        //定义一个二维数组，表示10个桶，每个桶就是一个一维数组
        int[][] bucket = new int[10][arr.length];
        //定义一个一维数组，记录每个桶中的有效个数
        int[] bucketElementCount = new int[10];

        //先得到数组中最大元素的位数
        int max = arr[0];
        for (int i = 1; i < arr.length; i++) {
            if (arr[i] > max) {
                max = arr[i];
            }
        }
        int maxLength = (max + "").length();

        //完成基数排序一共需要maxLength次排序
        for (int i = 0, n = 1; i < maxLength; i++, n *= 10) {
            //针对每个元素的位（个位、十位、百位）进行排序处理（放入对应的桶中）
            for (int value : arr) {
                //取出每个元素个位的值
                int digitOfElement = value / n % 10;
                //放入对应的桶中
                bucket[digitOfElement][bucketElementCount[digitOfElement]] = value;
                bucketElementCount[digitOfElement]++;
            }
            //按照这个桶的顺序（一维数组的下标依次取出数据，放入原数组）
            int index = 0;
            //遍历每一个桶，
            for (int k = 0; k < 10; k++) {
                //如果桶中有数据，才放入原数组
                if (bucketElementCount[k] != 0) {
                    for (int l = 0; l < bucketElementCount[k]; l++) {
                        arr[index++] = bucket[k][l];
                    }
                }
                //处理完每个桶后，一定要将每个桶的有效个数清空！！
                bucketElementCount[k] = 0;
            }
        }
    }
```

## 1.9、桶排序On<sup>2</sup>

将待排序元素划分到不同的桶。先扫描一遍序列求出最大值 max 和最小值 min ， 

设桶的个数为 k ，则把区间 [min, max] 均匀划分成k个区间，每个区间就是一个桶。将序列中的元素分配到各自的桶。
**对每个桶内的元素进行排序。可以选择任意一种排序算法。** 将各个桶中的元素合并成一个大的有序序列。
假设数据是均匀分布的，则每个桶的元素平均个数为 n/k 。**桶越多，时间效率就越高，而桶越多，空间就越大。**



> **计数排序O(n+k)**本质上是一种特殊的**桶排序**，当桶的个数最大的时候，就是计数排序。































# 3、查找算法 

## 2.1、线性查找

基本思想：最简单的一种查找算法，直接遍历数据即可

代码实现：

```java
    /**
     * 线性查找
     * @param arr  待查找数组
     * @param value  待查找的值
     * @return 查找到的下标
     */
    public static int search(int[] arr, int value){
        for(int i = 0; i < arr.length; i++){
            if(arr[i] == value){
                return i;
            }
        }
        return -1;
    }
```

## 2.2、二分查找

基本思想：

1、首先确定该数组的中间的下标 

​          mid = (left + right)/2;

2、然后让待查找的数findVal与arr[mid]进行比较

​          2.1 findVal > arr[mid] 说明要查找的数在mid的右边，向右递归

​          2.2 findVal < arr[mid] 说明要查找的数在mid的左边，向左递归

​          2.3 findVal = arr[mid] 说明找到，直接返回

什么时候需要去结束递归？

- 找到就结束递归
- 递归完整个数组，仍然没有找到findVal，也需要结束递归，当left>right

代码实现：

```java
     /**
     * 二分查找
     * @param arr     数组
     * @param left    左边的索引
     * @param right   右边的索引
     * @param findVal 待查找的值
     * @return 如果找到返回下标，如果没有，返回-1
     */
    public static int search(int[] arr, int left, int right, int findVal) {
        if (left > right) {
            return -1;
        }
        int mid = (left + right) / 2;
        int midVal = arr[mid];

        if (findVal < midVal) { //向左递归
            return search(arr, left, mid - 1, findVal);
        } else if (findVal > midVal) {  //向右递归
            return search(arr, mid + 1, right, findVal);
        } else {
            return mid;
        }
    }
```

## 2.3、插值查找

基本思想：

- 插值查找算法类似于二分查找，不同的是插值查找每次从自适应mid处开始查找
- int mid = left + (right – left) * (findVal – arr[left]) / (arr[right] – arr[left])

插值查找注意事项：

1. 对于数据量较大，关键字分布比较均匀的查找表来说，采用插值查找, 速度较快.
2. 关键字分布不均匀的情况下，该方法不一定比折半查找要好

代码实现：

```java
     /**
     * 插值查找
     * @param arr  数组
     * @param left  左边的索引
     * @param right   右边的索引
     * @param findVal  待查找的值
     * @return  如果找到返回下标，如果没有，返回-1
     */
    public static int search(int[] arr, int left, int right, int findVal) {
        if (left > right || findVal < arr[left] || findVal > arr[right]) {
            return -1;
        }
        //自适应mid
        int mid = left + (right - left) * (findVal - arr[left]) / (arr[right] - arr[left]);
        int midVal = arr[mid];
        if (findVal < midVal) {
            return search(arr, left, mid - 1, findVal);
        } else if (findVal > midVal) {
            return search(arr, mid + 1, right, findVal);
        }else{
            return mid;
        }
    }
```





# 4、工厂方法模式

实际上提供了一种创建对象最佳的方式。在工厂模式中，我们创建对象时不会向客户端暴露创建逻辑，并且是通过使用一个公共的接口来指向新创建的对象。实现了创建者与调用者分离。工厂模式又分为简单工厂模式、工厂方法模式、抽象工厂模式。

## 4.1、简单工厂模式

用来生产同一等级结构中的任意产品。（不支持扩展增加产品）

````java
interface Car{
    void run();
}
class B implements Car {
    public void run(){System.out.println("我在开宝马");}
}
class A implements Car {
    public void run(){System.out.println("我在开奥迪");}
}
public class SimpleFactory {
    public static Car create(String name){
        if("".equals(name)){return null;}
        if("奥迪".equals(name)){return new A();}
        if("宝马".equals(name)){return new B();}
        return null;
    }
}
````

## 4.2、工厂方法模式

用来生产同一等级结构中的固定产品。（支持扩展增加产品）

````java
interface Car{
    void run();
}
interface Factory{
    Car create();
}
class B implements Car {
    public void run(){System.out.println("我在开宝马");}
}
class A implements Car {
    public void run(){System.out.println("我在开奥迪");}
}

public class BFactory implements Factory {
    public Car create(){return new B();}
}
public class AFactory implements Factory {
    public Car create(){return new A();}
}
````

## 4.3、抽象工厂模式

用来生产不同产品簇中的全部产品（支持扩展增加产品簇）

```java
//抽象产品
interface Car{
    void run();
}
interface Engine{
    void run();
}
//抽象工厂
interface Factory{
    Car createCar();
    Engine createEngine();
}
//具体产品
class B implements Car {
    public void run(){System.out.println("我在开宝马");}
}
class A implements Car {
    public void run(){System.out.println("我在开奥迪");}
}
class EngineA implements Engine{
    public void run(){System.out.println("转得快");}
}
class EngineB implements Engine{
    public void run(){System.out.println("转得慢");}
}
//具体工厂
public class BFactory implements Factory {
    public Car createCar(){return new B();}
    public Engine createEngine(){return new EngineB();}
}
public class AFactory implements Factory {
    public Car createCar(){return new A();}
    public Engine createEngine(){return new EngineA();}
}
```



# 5、单例模式

保证一个类只有一个实例，并且提供一个访问该实例的全局访问点

## 3.1、饿汉式

```java
public class Hungry {
  private Hungry() {
 }
  private final static Hungry hungry = new Hungry();
  public static Hungry getInstance() {
    return hungry;
 }
}
```

饿汉式是最简单的单例模式的写法，保证了线程的安全（类初始化的时间实例化），在很长的时间里，我都是饿汉模式来完成单例的，因为够简单，后来才知道饿汉式会有一点小问题，看下面的代码：

```java
public class Hungry {
  private byte[] data1 = new byte[1024];
  private byte[] data2 = new byte[1024];
  private byte[] data3 = new byte[1024];
  private byte[] data4 = new byte[1024];
 
  private Hungry() {
 }
  private final static Hungry hungry = new Hungry();
  public static Hungry getInstance() {
    return hungry;
 }
}
```

在Hungry类中，我定义了四个byte数组，当代码一运行，这四个数组就被初始化，并且放入内存了，如果长时间没有用到getInstance方法，不需要Hungry类的对象，这不是一种浪费吗？我希望的是 只有用到了 getInstance方法，才会去初始化单例类，才会加载单例类中的数据。所以就有了 第二种单例模式：懒汉式。

## 3.2、懒汉式

正常的 懒汉式单例：

```java
public class LazyMan {
  private LazyMan() {
    System.out.println(Thread.currentThread().getName()+"Start");
 }
  private static LazyMan lazyMan;
  public static LazyMan getInstance() {
    if (lazyMan == null) {
      lazyMan = new LazyMan();
   }
    return lazyMan;
 }
  // 测试并发环境，发现单例失效
  public static void main(String[] args) {
    for (int i = 0; i < 10; i++) {
      new Thread(()->{
        LazyMan.getInstance();
          }).start();
   }
 }
}
```

## 3.4、DCL懒汉式

```java
public class LazyMan {
  private LazyMan() {
 }
  private static LazyMan lazyMan;
  public static LazyMan getInstance() {
    if (lazyMan == null) {
      synchronized (LazyMan.class) {
        if (lazyMan == null) {
          lazyMan = new LazyMan();
       }
     }
   }
    return lazyMan;
 }
}
```

DCL懒汉式的单例，保证了线程的安全性，又符合了懒加载，只有在用到的时候，才会去初始化，调用
效率也比较高，但是这种写法在极端情况还是可能会有一定的问题。因为

```java
lazyMan = new LazyMan(); 
```

不是原子性操作，至少会经过三个步骤：

1. 分配对象内存空间
2. 执行构造方法初始化对象
3. 设置 instance 指向刚分配的内存地址

==由于指令重排，导致A线程执行 lazyMan = new LazyMan();的时候，可能先执行了第三步（还没执行第二步），此时线程B又进来了，发现lazyMan已经不为空了，直接返回了lazyMan，并且后面使用了返回的lazyMan，由于线程A还没有执行第二步，导致此时lazyMan还不完整，可能会有一些意想不到的错误，所以就有了下面一种单例模式。==

这种单例模式只是在上面DCL单例模式增加一个volatile关键字来避免指令重排：

```java
public class LazyMan {
  private LazyMan() {
 }
  private volatile static LazyMan lazyMan;
  public static LazyMan getInstance() {
    if (lazyMan == null) {
      synchronized (LazyMan.class) {
        if (lazyMan == null) {
          lazyMan = new LazyMan();
       }
     }
   }
    return lazyMan;
      }
}
```

## 3.3、静态内部类

还有这种方式是第一种饿汉式的改进版本，同样也是在类中定义static变量的对象，并且直接初始化，不过是移到了静态内部类中，十分巧妙。既保证了线程的安全性，同时又满足了懒加载。

```java
public class Holder {
  private Holder() {
 }
  public static Holder getInstance() {
    return InnerClass.holder;
 }
  private static class InnerClass {
    private static final Holder holder = new Holder();
 }
}
```

## 3.4、万恶的反射

万恶的反射登场了，反射是一个比较霸道的东西，无视private修饰的构造方法，可以直接在外面
newInstance，破坏我们辛辛苦苦写的单例模式。

```java
public static void main(String[] args) {
    LazyMan lazyMan1 = LazyMan.getInstance();
    Constructor<LazyMan> declaredConstructor = LazyMan.class.getDeclaredConstructor(null);
    
    declaredConstructor.setAccessible(true);
    LazyMan lazyMan2 = declaredConstructor.newInstance();
    System.out.println(lazyMan1.hashCode());
    System.out.println(lazyMan2.hashCode());
    System.out.println(lazyMan1 == lazyMan2);/
}
```

我们分别打印出lazyMan1，lazyMan2的hashcode，lazyMan1是否相等lazyMan2，结果显而易见，==不相等==；

那么，怎么解决这种问题呢？

```java
public class LazyMan {
  private LazyMan() {
    synchronized (LazyMan.class) {
      if (lazyMan != null) {
        throw new RuntimeException("不要试图用反射破坏单例模式");
     }
   }
 }
  private volatile static LazyMan lazyMan;
    public static LazyMan getInstance() {
    if (lazyMan == null) {
      synchronized (LazyMan.class) {
        if (lazyMan == null) {
          lazyMan = new LazyMan();
       }
     }
   }
    return lazyMan;
 }
}
```

在私有的构造函数中做一个判断，如果lazyMan不为空，说明lazyMan已经被创建过了，如果正常调用
getInstance方法，是不会出现这种事情的，所以直接抛出异常！

但是这种写法还是有问题：

上面我们是先正常的调用了getInstance方法，创建了LazyMan对象，所以第二次用反射创建对象，私有构造函数里面的判断起作用了，反射破坏单例模式失败。但是如果破坏者干脆不先调用getInstance方法，一上来就直接用反射创建对象，我们的判断就不生效了：

```java
public static void main(String[] args) {
  try {
    Constructor<LazyMan> declaredConstructor =
LazyMan.class.getDeclaredConstructor(null);
    declaredConstructor.setAccessible(true);
    LazyMan lazyMan1 = declaredConstructor.newInstance();
    LazyMan lazyMan2 = declaredConstructor.newInstance();
    System.out.println(lazyMan1.hashCode());
    System.out.println(lazyMan2.hashCode());
 } catch (Exception e) {
    e.printStackTrace();
 }
}
```

那么如何防止这种反射破坏呢？

```java
public class LazyMan {
  private static boolean flag = false;
  private LazyMan() {
    synchronized (LazyMan.class) {
      if (flag == false) {
        flag = true;
     } else {
        throw new RuntimeException("不要试图用反射破坏单例模式");
     }
   }
 }
  private volatile static LazyMan lazyMan;
  public static LazyMan getInstance() {
    if (lazyMan == null) {
      synchronized (LazyMan.class) {
        if (lazyMan == null) {
          lazyMan = new LazyMan();
       }
     }
   }
    return lazyMan;
      }
}
```

在这里，我定义了一个boolean变量flag，初始值是false，私有构造函数里面做了一个判断，如果
flag=false，就把flag改为true，但是如果flag等于true，就说明有问题了，因为正常的调用是不会第二
次跑到私有构造方法的，所以抛出异常。

看起来很美好，但是还是不能完全防止反射破坏单例模式，因为可以利用反射修改flag的值。

```java
class Demo02{
  public static void main(String[] args) {
    try {
      // 通过反射创建对象
      Constructor<LazyMan> declaredConstructor =
LazyMan.class.getDeclaredConstructor(null);
      Field field = LazyMan.class.getDeclaredField("flag");
      field.setAccessible(true);
      // 通过反射实例化对象
      declaredConstructor.setAccessible(true);
      LazyMan lazyMan1 = declaredConstructor.newInstance();
      System.out.println(field.get(lazyMan1));
      System.out.println(lazyMan1.hashCode());
      //通过反射，修改字段的值！
      field.set(lazyMan1,false);
      LazyMan lazyMan2 = declaredConstructor.newInstance();
      System.out.println(field.get(lazyMan2));
      System.out.println(lazyMan2.hashCode());
   } catch (Exception e) {
      e.printStackTrace();
   }
 }
}
```

并没有一个很好的方案去避免反射破坏单例模式，所以轮到我们的枚举登场了。

## 3.5、枚举

枚举类型是Java5 中新增特性的一部分，它是一种特殊的数据类型，之所以特殊是因为它既是一种类
(class)类型却又比类类型多了些特殊的约束，但是这些约束的存在也造就了枚举类型的简洁性、安全性
以及便捷性。

```java
public enum EnumSingleton {
  INSTANCE;
  public EnumSingleton getInstance(){
    return INSTANCE;
 }
}
class Demo04{
  public static void main(String[] args) {
    EnumSingleton singleton1=EnumSingleton.INSTANCE;
    EnumSingleton singleton2=EnumSingleton.INSTANCE;
    System.out.println("正常情况下，实例化两个实例是否相同："+
(singleton1==singleton2));
      }
}
```

枚举是目前最推荐的单例模式的写法

- 编写简单
- 保证线程的安全
- 有效的防止反射破坏单例模式

我们可以看下newInstance的源码，反编译查看下枚举的源码：

```java
javap -p EnumSingleton.class
Compiled from "EnumSingleton.java"
public final class 单例模式.EnumSingleton extends java.lang.Enum<单例模式.EnumSingleton> {
    public static final 单例模式.EnumSingleton INSTANCE;
    private static final 单例模式.EnumSingleton[] $VALUES;
    public static 单例模式.EnumSingleton[] values();
    public static 单例模式.EnumSingleton valueOf(java.lang.String);
    private 单例模式.EnumSingleton();
    public 单例模式.EnumSingleton getInstance();
    static {};
}
```

这个看的不清楚，我们可以下 jad 进行反编译，我们的素材中也都有！

```bash
jad -sjava EnumSingleton.class
# 会生成一个java文件
Parsing EnumSingleton.class... Generating EnumSingleton.java
```

我们点开里面的源码

````java
// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
// Jad home page: http://www.kpdus.com/jad.html
// Decompiler options: packimports(3)
// Source File Name:  EnumSingleton.java
package 53554F8B6A215F0F;
public final class EnumSingleton extends Enum
{
  public static EnumSingleton[] values()
 {
    return (EnumSingleton[])$VALUES.clone();
 }
  public static EnumSingleton valueOf(String name)
 {
    return (EnumSingleton)Enum.valueOf(53554F8B6A215F0F/EnumSingleton,
name);
 }
  private EnumSingleton(String s, int i)
 {
      super(s, i);
 }
  public EnumSingleton getInstance()
 {
    return INSTANCE;
 }
  public static final EnumSingleton INSTANCE;
  private static final EnumSingleton $VALUES[];
  static
 {
    INSTANCE = new EnumSingleton("INSTANCE", 0);
    $VALUES = (new EnumSingleton[] {
      INSTANCE
   });
 }
}
````

再次尝试破坏看一下！

```java
package 单例模式;
import java.lang.reflect.Constructor;
public enum EnumSingleton {
  INSTANCE;
  public EnumSingleton getInstance(){
    return INSTANCE;
 }
}
class Demo04{
  public static void main(String[] args) throws Exception {
    EnumSingleton singleton1=EnumSingleton.INSTANCE;
    EnumSingleton singleton2=EnumSingleton.INSTANCE;
    System.out.println("正常情况下，实例化两个实例是否相同："+
(singleton1==singleton2));
    //Constructor<EnumSingleton> constructor =
EnumSingleton.class.getDeclaredConstructor(); //自身的类没有无参构造方法
    Constructor<EnumSingleton> constructor =
EnumSingleton.class.getDeclaredConstructor(String.class,int.class);
    constructor.setAccessible(true);
    EnumSingleton enumSingleton = constructor.newInstance();
 }
}
```

试图破坏，真的破坏不了！



# 4、生产者消费者模式

1. 用 synchronized 加锁，然后使用 object 原生的 wait() 和 notify() 做同步 
2. 用 Lock 加锁，然后用 condition 的 await() 和 signal() 做同步 
3. 直接使用 concurrent.BlockingQueue
4. 使用 PipedInputStream/PipedOutputStream
5. 使用信号量 semaphore

使用wait和notify/notifyAll来实现：

```java
import java.util.LinkedList;

public class MyContainer1<T> {
    final private LinkedList<T> lists = new LinkedList<>();
    final private int MAX = 10;//最多10个元素
    private int count = 0;

    /**问题1：
     * 为什么下面对缓冲池的判断使用的是while而不是if?
     * 当缓冲池已满的话，再有生产者线程运行，线程就会陷入等待
     * 举个栗子，假设当前缓冲池满，生产者线程A,B陆续运行
     *如果是使用if的话：
     * A,B线程进入if方法体里，调用wait，统统陷入等待
     * 等到有一个消费者在结束时进行唤醒，此时A,B均被唤醒，那么他们此时都不会在进行缓冲池是否满的判断了，他们都会直接到if语句的下一句继续运行
     * 假设A先拿到锁，执行add操作，然后在结束时继续唤醒，当B拿到锁后，也是直接进行add操作，没有去判断此时缓冲池的情况，这样就会出问题
     * 如果是使用while的话
     * 在线程每次醒来后，都先去检查缓冲池的情况，若符合要求，才进行下一步操作，若不符合要求，还会继续等待
     *
     */
    public synchronized void put(T t) {
        while (lists.size() == MAX) {//想想这里为什么使用while而不是if？
            try {
                this.wait();//wait()大多数情况下都和while()在一起
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        lists.add(t);
        ++count;
        this.notifyAll();//前面生产了，通知所有消费者线程进行消费
    }

    /**问题2：
     * 为什么最后调用的是notifyAll()而不是notify()?
     * 因为在该对象上等待的可能不仅有消费者，还有生产者，若随机叫醒的一个又是生产者的话，
     * 若此时缓冲池已满，生产者就陷入等待，消费者便永远也不会被唤醒，整个程序陷入死锁
     * 所以优先使用notifyAll()
     *
     */

    public synchronized T get() {
        T t = null;
        while (lists.size() == 0) {//想想这里为什么使用while而不是if
            try {
                this.wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        t=lists.removeFirst();
        --count;
        this.notifyAll();//前面消费了，通知所有生产者线程进行生产
        return t;
    }


}
```

使用Lock和Condition来实现：

```java
package ThreadLearn.A005_Q;

import java.util.LinkedList;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;


public class MyContainer2<T> {
    final private LinkedList<T> lists = new LinkedList<>();
    final private int MAX = 10;//最多10个元素
    private int count = 0;

    private Lock lock=new ReentrantLock();
    private Condition producer =lock.newCondition();
    private Condition consumer =lock.newCondition();
    public  void put(T t) {
            try {
                lock.lock();
                while(lists.size()==MAX){
                    producer.await();
                }
                lists.add(t);
                ++count;
                consumer.signalAll();//通知所有消费者线程进行消费
            } catch (InterruptedException e) {
                e.printStackTrace();
            }finally {
                lock.unlock();
            }
    }

    public synchronized T get() {
        T t = null;
            try {
                lock.lock();
                while(lists.size()==0){
                    consumer.await();
                }
                t=lists.removeFirst();
                --count;
                producer.signalAll();//通知生产者进行生产
            } catch (InterruptedException e) {
                e.printStackTrace();
            }finally {
                lock.unlock();
            }
        return t;
    }

    public static void main(String[] args) {
        MyContainer2<String> c=new MyContainer2<>();
        //启动消费者线程
        for (int i = 0; i <10 ; i++) {
            new Thread(()->{
                for(int j=0;j<5;j++) System.out.println(c.get());
            },"c"+i).start();
        }
        try{
            TimeUnit.SECONDS.sleep(2);
        }catch (InterruptedException e){
            e.printStackTrace();
        }
        //启动生产者者线程
        for (int i = 0; i <2; i++) {
            new Thread(()->{
                for(int j=0;j<25;j++) c.put(Thread.currentThread().getName()+" "+ j);
            },"p"+i).start();
        }

    }
}
```

对比两种方式可以看出，Condition的方式可以更加精确的指定哪些线程被唤醒。