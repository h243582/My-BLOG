# 一、`http`

## 1、概念

超文本传输协议

## 2、http协议的组成

包括请求 和 响应，在网页地址栏输入一个地址之后，浏览器会把请求发送给服务器，服务器收到响应，返回信息给浏览器

## 3、http请求

### （1）请求头

==主机名，cookie，User-Agent==

<img src="https://heyufei-1305336662.cos.ap-shanghai.myqcloud.com/my_img/202109022055175.png" alt="img" style="zoom: 50%;" />

### （2）请求行

==请求方式（post、get）、请求的资源 内容==

### （3）请求体

 当请求方式是post时，请求体会有请求参数格式如下：

    username=zhangsan&password=123
当请求方式时get时，请求参数是不会出现在请求体中，会拼接在url地址后面：

```
http://localhost:8080...？username=zhangsan&password=123
```

## 4、http响应

### （1）响应头

location路径，Content-Disposition解析的资源，Set-Cookie设置cookie

<img src="https://heyufei-1305336662.cos.ap-shanghai.myqcloud.com/my_img/202109022126248.png" alt="img" style="zoom:50%;" />

### （2）响应行

包括==状态码== 返回给客户端

### （3）响应体

**显示正文页面内容**，返回给客户端

## 5、**说说HTTP和HTTPS**

### （1）概述

http是无连接，无状态的（每次连接只处理一个请求，发送完数据后，不会记录）

**而https简单讲是HTTP的安全版**，即HTTP下加入SSL层，**主要是来确认网站的真实性和数据传输的安全**。

### （2）区别

http的数据是**明文**传输，而**`https`**是加密传输，需要用到ca证书

http使用==80==端口，而https是==443==端口

http的速度比https要快

## 6、**`https`中`SSL`握手的过程**

- 首先客户端给出协议版本号，一个客户端生成的随机数，以及支持的加密方式

- 服务端确认双方使用的加密方式，给出数字证书，以及一个服务器生成的随机数

- 客户端确认数字证书有效，然后生成一个新的随机数，并使用数字证书中的公钥，加密这个随机数，发个服务端

- 服务端使用自己的私钥，获取客户端发来的随机数

- 客户端和服务端根据约定的加密方式，使用前面的三个随机数，生成密钥


# 二、`Tcp/Ip`

## 1、**它的模型，做了事情**

TCP/IP模型分为五层，分别是应用层，传输层，网络层，数据链路层，物理层

TCP/IP协议群主要是==报文的拆分==，增加协议头，==数据的传输==，==路由和寻址以及数据的重组==

## 2、**建立连接-三次握手**

1. 主机A发送syn到主机B，要求建立a到b的连接。（**此时主机A的状态为syn_sent**）

2. 主机B回复`ack`+`syn`，要求建立b到a的连接，主机B的状态为syn_rcvd

   - （这里的`ack`和`syn`数据报本来是两个，但是==仅标志位不同，可以合并==,所以为什么不是四次的原因）

3. 主机A回复B中`syn`的`ack`。主机A的状态为established，建立A到B的连接

   **最后：**主机B接收到第3步的数据报，建立B到A 的连接，主机B的状态置为established

## 3、**syn为什么有两个**

因为双方都有连接 ，你给我发，我给你发是分开的

## 4、**第二步中，为什么是`ack`+`syn`**

本质上是一个发`syn`请求，一个发`ack`接收，而且==两个数据报方向一致的时候是可以合并==

## 5、**第三步中，`ack`确认接收谁**

接收第二步的`syn`

## 6、**断开连接-四次挥手**

1. 主机A发送`fin`到主机B，请求关闭a到b的连接
2. 主机B回复`ack`，主机B的状态置为close_wait（**表示可以关闭了**）
3. 主机B发送`fin`到主机A，请求关闭b到a的连接
4. 值即A回复`ack`（第三步的`fin`），状态置为time_wait（**表示可以关闭了**）

之后：主机B接收到第四步的数据报，状态置为closed

最后：主机A经过2MSL（超时等待时间）之后，状态置为closed

## 7、**TCP和UDP的区别**

1. TCP是有连接的可靠传输协议，而UDP是无连接的
2. UDP传时数据是有大小限制的，而TCP没有
3. UDP是面向数据报的，而TCP是面向数据流的
4. TCP保证数据正确性，顺序性，而UDP不能保证
5. UDP的传输速率高于TCP

## 8、**怎么用UDP可靠传输**

引入==序列号==, 保证数据顺序

引入==确认应答==, 确保对端收到了数据

引入==超时重传==, 如果隔一段时间没有应答, 就重发数据

## 9、**正向代理和反向代理的区别**

==正向代理==：要访问的服务器==**只知道代理服务器**==来访问它，并==**不知道真实的客户端**==是谁

==反向代理==：反向代理正好相反。对于客户端来说，反向代理就好像目标服务器，客户端向反向代理发送请求，接着反向代理判断请求走向何处，隐藏了真实的服务器



**DNS解析（DNS找IP）**

当浏览器中输入www.bai.com域名时，操作系统会检查自己本地的hosts文件查看是否有这个网址的映射关系，如果有，直接调用

如果没有，则查找本地的DNS解析器缓存，如果有，则直接返回IP

如果没有，再找TCP/IP参数中设置的本地的DNS服务器，如果该域名包含再本地配置区域的资源中，则返回解析结果。

也可能查找的域名，本地的DNS服务器已经缓存在网址的映射关系，那么直接调用这个IP

如果本地DNS服务器也无法解析，会根据本地的DNS服务器是否设置转发器进行查询

如果是未转发模式，本地DNS会把请求发给13台根DNS，由对应的根服务器（例如.com）向下找，最后完成解析

如果是转发模式，那么DNS服务器会把请求一级一级向上传，往上找，直到传到根DNS

**GET和POST的区别**

get的请求数据只能放在url中，post的数据，可以放在url和请求体

url长度有限制，所有get方法请求数据不能太多，并且url只能传输ascli字符

安全性高，post可以存放请求数据在请求体，相对更加安全

GET主要是从服务端获取数据，而POST请求主要是将数据发送到服务端

POST请求刷新会被重新提交，但Get请求不会

**常见的状态码**

400:客户端请求语法错误，服务端无法理解

405：映射找到了，但是客户端请求方法和服务端提供的请求方法不匹配

500:服务端内部报错

403：无权限

**输入一个URL到浏览器中，会发生什么**

域名解析(DNS解析)

发起TCP的三次握手

建立TCP连接后发起HTTP请求（如果浏览器存储了该域名下的Cookies，那么会把Cookies放入HTTP请求头里发给服务器）

服务器端响应http请求，浏览器得到html代码

浏览器解析html代码，并请求html代码中的资源

浏览器对页面进行渲染呈现给用户
