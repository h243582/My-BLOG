# 一、数据库引擎

1、`Archive`引擎

​		存储限制`none`，啥权限也没有

2、`InnoDB`引擎

​		存储限制`64TB`，==**支持事物**==，==**支持数索引**==，==**支持数据缓存**==，==**支持外键**==

3、`Memory`引擎

​		存储限制`RAM`，支持数索引，支持数据缓存，==**支持外键**==

4、`MyISAM`引擎

​		存储限制`256TB`，支持全文索引，支持数索引

# 二、`sql`调优

1. 使用group by 分组查询是，默认分组后，还会排序，可能会降低速度，

   **在`group by` 后面增加 `order by null` 就可以防止排序.**

2. 最好不要给数据库留 NULL，尽可能的使用 NOT NULL 填充数据库.

   备注、描述、评论之类的可以设置为 NULL，其他的，最好不要使用 NULL。

3. 对查询进行优化，要尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引

4. 减少 IO 次数

5. 降低 CPU 计算（order by, group by,distinct，排序）

6. 尽量用连接（join）代替子查询（不需要在内存创建临时表），尽量少 join

7. 尽量避免 select *

8. 尽量少 or,使用 union all 或者是union(必要的时候)的方式来代替“or”会得到更好

9. 避免类型转换

10. 优先优化高并发的 `SQL`

11. 从全局出发优化，充分考虑系统中所有的 `SQL`







# 三、事务四大特性

### 1、原子性A

是指一个事务的所有操作，要么全部成功，要么全部失败

### 2、一致性C

执行前和执行后必须一致。不能一个加了钱，一个没加钱

### 3、隔离性I

每个用户访问数据库不会互相干扰

### 4、持久性D

事务提交后永久性保存



# 四、事务隔离级别

## 1、为什么有隔离级别

### （1）脏读

一个事务读取了另一个还未提价的事务中的内容

### （2）不可重复读

查询间隔，查询内容被另一个事务修改并提交了。导致多次查询返回了不同的值

### （3）幻读（虚读）

**事务A**修改所有行为“**无**”，同时**事务B**修改一个行为“有”，事务A修改完一看，诶，漏了一个

## 2、事务的隔离级别

![image-20210721193311759](https://heyufei-1305336662.cos.ap-shanghai.myqcloud.com/my_img/20210721193311.png)

### （1）读未提交**Read uncommitted**

一个事务写数据的时候，其他事务全部不允许写数据，但是允许读。

这种级别可以通过"**排它写锁**"和 不排斥读线程实现。

#### 避免了**更新丢失**，却可能出现**脏读**

### （2）读已提交**Read committed**

**读事务**的时候，允许其他事务读写；

**写事务**的时候，禁止其他事务**访问**该行数据

#### 避免了**脏读**和**更新丢失**，但是可能出现**不可重复读**

### （3）可重复读取**Repeatable read**

==**`MySQL`默认的隔离级别是*可重复读*。**==

**（保证多次查询结果相同）**

事务A读取这个数据（不可写），在在这个事务还没结束时，其他事务不能访问该数据(包括了读写)

(读取数据的事务)可以通过“共享读镜”和“排他写锁”实现。

#### 解决了**更新丢失**、**脏读**、**不可重复读**、但是还会出现**幻读**

### （4）可序化**Serializable**

事务只能一个接着一个地执行（**不可并发**）

仅仅通过“行级锁”是无法实现序列化的，必须通过其他机制保证新插入的数据不会被执行查询操作的事务访问到。

它以锁表的方式(类似于Java多线程中的锁)使得其他线程只能在锁外等待

**序列化是最高的事务隔离级别**，**性能很低**，一般**很少使用**

#### 不仅可以避免**脏读**、**不可重复读**，还避免了幻读



# 五、缓存

## 1、缓存处理流程

取数据的时候先在缓存中找，没有的话再到数据库中查询，返回结果

![img](https://heyufei-1305336662.cos.ap-shanghai.myqcloud.com/my_img/20210818094833.png)

## 2、缓存穿透

缓存和数据库都没有数据，但是用户一直请求。这时候用户很可能是攻击者

### 解决方案

1. 接口层增加效验，用于鉴定，id<0直接拦截
2. 如果缓存和数据库中都无数据，这时候可以把key-value写为key-null，缓存有效时间设置短一点：30秒，太长的话用户也用不好。可以防止攻击用户反复用同一个id暴力攻击

## 3、缓存击穿

缓存中没有数据，数据库中有，但是刚刚过期了，就在这个过期之后：因为并发用户特别多，同时读取缓存没读到数据又跑到数据库取数据，导致数据库压力瞬间扩大。

### 解决方法

设置热点数据永不过期

加互斥锁

![img](https://heyufei-1305336662.cos.ap-shanghai.myqcloud.com/my_img/202108181641570.png)
#### 说明

1. 缓存中有数据，直接走上述代码13行后就返回结果了
2. 缓存中没有数据，第1个进入的线程，获取锁并从数据库去取数据，==没释放锁之前，其他并行进入的线程会等待100ms，再重新去缓存取数据==。==防止都去数据库重复取数据==，重复往缓存中更新数据情况出现。
3. 当然这是简化处理，理论上如果能根据key值加锁就更好了，就是线程A从数据库取key1的数据并不妨碍线程B取key2的数据，上面代码明显做不到这点。

## 4、缓存雪崩

缓存中大量数据都过期了，这时候查询量巨大甚至死机

缓存击穿指的是并发查询一条，但是缓存雪崩是很多条数据都过期 导致很多条都要查数据库

### 解决方案

1. 缓存数据过期时间设置随机，防止同一时间大量数据过期
2. 如果缓存数据库是分布式部署，那就将热点数据均匀分布在个个缓存数据库中
3. 设置那些热点数据永不过期

# 六、索引

## 2、MySql中索引类型

### 聚簇索引

- 聚簇索引就是==主键索引==
- 聚簇索引的叶子节点存储的是整行数据

### 非聚簇索引

- 非聚簇索引就是==普通索引==

- 非聚簇索引存储的是==索引值==和==主键值==

## 1、`innoDB`(**聚簇索引**)的索引类型

### （1）**主键索引**

- ==**一个表只能一个主键，一个主键索引**==

- 默认的都有，`primary`设置后，自动创建主键索引
- `InnoDB`通过主键来实现聚簇索引，如果没有主键的话，它会选择一个唯一非空的索引来实现，如果再没有的话，它会隐式生成一个主键实现聚簇索引
- alert table user add **primary key**(id)

### （2）**普通索引**

- 也叫 **单列索引，单值索引**
- 随便一个字段都可以建立索引，可以重复
- alert table user add **index**  idx_name(name)

### （3）**唯一索引**

- 一个表中可以有多个唯一索引。
- 值必须唯一，可以为空，但是只能有一个空
- alert table user add **unique** idx_id_card(id_card)

### （4）**复合索引**

- 多个列**组合索引**，
- ==最左原则==添加了age,name时，可以用age或者age和name，但是不能单独用name
- alert table user add **index**  idx_age_name(age,name)

## 2、Full Text全文索引

因为全文索引==会对文本进行====分词==，所以只能用于`char`，`varchar`，`text`

允许在==索引列==中插入==重复值==和==空值==

`MyIsam`(权限最低的那个)存储引擎支持全文索引

## 3、什么情况无法用索引

### 1．查询语句中使用LIKE关键字

- 如果第一个字符为`%`，索引不会被使用。
- 只要`%`不在第一个位置，索引就会被使用。

### 2.查询语句中使用多列索引

如果查询使用了组合索引，那必须要使用了左侧第一个字段，才会调用索引

### 3.查询语句中使用or关键字

如果`or`的时候其中有字段不是索引，就不能使用索引

`username = '123' or password='121'`

## 4、什么时候要用索引

- 在需要排序的列上创建索引，因为索引已经排序
- 在经常使用在where子句中的列上面创建 [索引](https://baike.baidu.com/item/索引)，加快条件的判断速度。
- 在经常需要搜索的列上加索引，可以很快搜索到
- 在外键上面建立索引

## 5、什么时候不用索引

- 使用不了索引的时候（模糊查询%在左边，组合查询的时候不遵循最左原则，or的时候有一侧不是索引）
- 查询少的列不用索引
- 数据值范围很少的列也不用索引，比如说性别
- imge、url这种的别加索引
- 如果哪一项需要经常修改的话，也最好不要加，不然索引的自动维护过程会很慢



